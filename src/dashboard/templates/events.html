{% extends "base.html" %}
{% block title %}WIDS Events & Labeling{% endblock %}
{% block content %}
<section id="eventsSection" class="dashboard-section active">
    <div class="page-header d-flex justify-content-between align-items-center">
        <h1 class="h2 mb-0">Events & Labeling</h1> <span id="eventCount" class="text-muted">Total: 0 | Showing: 0</span>
    </div>
    <div class="alert alert-info small mt-3 d-none" role="alert" id="sseStatus">
        <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
        Live stream connected. Waiting for new events...
    </div>
    <div class="table-container mt-3">
        <div class="table-responsive">
            <table class="table table-hover table-sm align-middle">
                <thead class="sticky-top"> {# Table Header #} </thead>
                <tbody id="eventsTableBody">{# Table Body #}</tbody>
            </table>
        </div>
    </div>
</section>
<div class="modal fade" id="eventDetailsModal" tabindex="-1">{# Modal Content #}</div>
{% endblock %}

{% block scripts %}
<script>
    // DOM Elements, State (Same as before)
    const eventsTableBody = document.getElementById('eventsTableBody');
    const unlabeledOnlySwitch = document.getElementById('unlabeledOnlySwitch');
    const limitSelect = document.getElementById('limitSelect');
    const eventCountSpan = document.getElementById('eventCount');
    const eventDetailsModalEl = document.getElementById('eventDetailsModal');
    const eventDetailsModal = eventDetailsModalEl ? new bootstrap.Modal(eventDetailsModalEl) : null;
    const labelForm = document.getElementById('labelForm');
    const sseStatusDiv = document.getElementById('sseStatus'); // SSE Status indicator
    // Modal elements...
    let currentEventsData = []; let isFetchingEvents = false;

    // API Endpoints
    const EVENTS_ENDPOINT = `${WIDS_API_BASE_URL}/events/`;
    const LABEL_ENDPOINT = `${WIDS_API_BASE_URL}/events/label`;
    const SSE_ENDPOINT = `${WIDS_API_BASE_URL}/events/stream`; // SSE endpoint

    // --- Rendering Functions ---
    function createTableRow(event) {
        // Creates a single table row HTML string from an event object
        const predictionBadge = event.prediction === 1 ? `<span class="badge bg-danger-subtle text-danger-emphasis prediction-badge">Anomaly</span>` : `<span class="badge bg-success-subtle text-success-emphasis prediction-badge">Normal</span>`;
        const labelBadge = event.human_label ? `<span class="badge bg-info-subtle text-info-emphasis label-badge">${event.human_label}</span>` : `<span class="badge bg-warning-subtle text-warning-emphasis label-badge">Unlabeled</span>`;
        const labelStatus = event.human_label ? 'Labeled' : 'Unlabeled';
        const uidShort = event.event_uid ? event.event_uid.substring(0, 12) + '...' : 'N/A';

        return `
                <tr>
                    <td><small>${formatTimestamp(event.timestamp)}</small></td>
                    <td><small class="font-monospace">${uidShort}</small></td>
                    <td>${predictionBadge}</td>
                    <td>${labelBadge}</td>
                    <td>${labelStatus}</td>
                    <td><button class="btn btn-sm btn-outline-primary" onclick="showDetails('${event.event_uid}')"><i class="bi bi-pencil-square me-1"></i>View/Label</button></td>
                </tr>
            `;
    }

    function renderTable(events, append = false) {
        if (!eventsTableBody) return;
        // Clear only if not appending
        if (!append) {
            eventsTableBody.innerHTML = '';
        }
        // Remove placeholder if it exists
        const placeholder = eventsTableBody.querySelector('.placeholder-row');
        if (placeholder) placeholder.remove();

        if (!events || events.length === 0) {
            if (!append) { // Only show if table was empty before
                eventsTableBody.innerHTML = '<tr class="placeholder-row"><td colspan="6" class="text-center text-muted py-5">No events found matching criteria.</td></tr>';
            }
            return;
        }

        let rowsHtml = '';
        events.forEach(event => {
            rowsHtml += createTableRow(event);
        });

        if (append) {
            // Prepend new rows to the top
            eventsTableBody.insertAdjacentHTML('afterbegin', rowsHtml);
        } else {
            eventsTableBody.innerHTML = rowsHtml;
        }
    }

    // --- Data Fetching ---
    async function fetchEvents() {
        if (isFetchingEvents || !limitSelect || !unlabeledOnlySwitch) return;
        isFetchingEvents = true;
        showLoading(true);
        const limit = limitSelect.value;
        const unlabeledOnly = unlabeledOnlySwitch.checked;
        const params = new URLSearchParams({ skip: 0, limit: limit, unlabeled_only: unlabeledOnly.toString() });
        try {
            const data = await fetchApi(`${EVENTS_ENDPOINT}?${params.toString()}`, {}, 'isFetchingEvents');
            currentEventsData = data.events || []; // Replace current data on fetch
            renderTable(currentEventsData, false); // Render fresh table
            if (eventCountSpan) eventCountSpan.textContent = `Total: ${data.total_count || 0} | Showing: ${currentEventsData.length}`;
        } catch (error) { /* Error handled by fetchApi */ renderTable([]); if (eventCountSpan) eventCountSpan.textContent = 'Total: - | Showing: -'; }
        finally { showLoading(false); isFetchingEvents = false; }
    }


    // --- Modal & Labeling ---
    function showDetails(eventUid) {
        if (!eventDetailsModal || !modalEventUid) return;
        const event = currentEventsData.find(e => e.event_uid === eventUid);
        if (!event) { showError(`Details not found for event UID: ${eventUid}`); return; }

        modalEventUid.textContent = event.event_uid;
        modalTimestamp.textContent = formatTimestamp(event.timestamp);
        modalPrediction.textContent = event.prediction === 1 ? 'Anomaly' : (event.prediction === 0 ? 'Normal' : 'Unknown');
        modalCurrentLabel.textContent = event.human_label || 'None';
        modalLabelTimestamp.textContent = formatTimestamp(event.label_timestamp);
        try { modalFeaturesData.textContent = JSON.stringify(event.features_data, null, 2); } catch (e) { modalFeaturesData.textContent = "Error displaying features."; }

        labelEventUidInput.value = event.event_uid;
        labelSubmitStatus.textContent = '';
        labelSubmitStatus.className = 'mt-2 small';
        if (submitLabelButton) submitLabelButton.disabled = false;
        if (submitLabelSpinner) submitLabelSpinner.classList.add('d-none');

        const currentLabelRadio = document.querySelector(`#labelForm input[value="${event.human_label}"]`);
        if (currentLabelRadio) currentLabelRadio.checked = true;
        else { const firstRadio = document.querySelector('#labelForm input[type="radio"]'); if (firstRadio) firstRadio.checked = true; }

        eventDetailsModal.show();
    }

    async function handleLabelSubmit(event) {
        event.preventDefault();
        if (!labelForm || !submitLabelButton || !submitLabelSpinner || !labelEventUidInput || !labelSubmitStatus) return;

        labelSubmitStatus.textContent = '';
        submitLabelButton.disabled = true;
        submitLabelSpinner.classList.remove('d-none');

        const eventUid = labelEventUidInput.value;
        const selectedLabel = labelForm.querySelector('input[name="humanLabelRadio"]:checked')?.value;

        if (!eventUid || !selectedLabel) { /* ... error handling ... */ return; }
        const payload = { event_uid: eventUid, human_label: selectedLabel };
        try {
            // Use common fetchApi from base.html
            const result = await fetchApi(LABEL_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            labelSubmitStatus.textContent = `Successfully labeled as '${selectedLabel}'. Refreshing...`;
            labelSubmitStatus.className = 'mt-2 small text-success';
            setTimeout(() => {
                eventDetailsModal?.hide();
                fetchEvents(); // Refresh event list only
            }, 1500);
        } catch (error) {
            labelSubmitStatus.textContent = `Error: ${error.message}`;
            labelSubmitStatus.className = 'mt-2 small text-danger';
            submitLabelButton.disabled = false;
            submitLabelSpinner.classList.add('d-none');
        }
    }

    // --- NEW: Server-Sent Events (SSE) Handling ---
    let eventSource = null;

    function connectSSE() {
        if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
            console.log("SSE connection already open.");
            return;
        }

        console.log("Connecting to SSE endpoint:", SSE_ENDPOINT);
        eventSource = new EventSource(SSE_ENDPOINT);

        eventSource.onopen = function (event) {
            console.log("SSE connection opened.");
            if (sseStatusDiv) {
                sseStatusDiv.classList.remove('d-none', 'alert-danger');
                sseStatusDiv.classList.add('alert-info');
                sseStatusDiv.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Live stream connected. Waiting for new events...';
            }
            hideError(); // Hide any previous global errors
        };

        eventSource.onmessage = function (event) {
            console.log("SSE message received:", event.data);
            try {
                const newEvent = JSON.parse(event.data);
                // Add to internal data array (optional, depends if you need full history in JS)
                // currentEventsData.unshift(newEvent); // Add to beginning

                // Prepend to table visually
                const newRowHtml = createTableRow(newEvent);
                if (eventsTableBody) {
                    // Remove placeholder if present
                    const placeholder = eventsTableBody.querySelector('.placeholder-row');
                    if (placeholder) placeholder.remove();
                    // Add new row at the top
                    eventsTableBody.insertAdjacentHTML('afterbegin', newRowHtml);
                    // Optional: Limit number of rows displayed?
                    // const maxRows = 200;
                    // while (eventsTableBody.rows.length > maxRows) {
                    //    eventsTableBody.deleteRow(-1); // Remove last row
                    // }
                }
                // Update counts (approximate, better to refetch stats periodically)
                if (eventCountSpan) {
                    // This is tricky without fetching total count again
                    // Maybe just indicate new event arrived
                }

            } catch (e) {
                console.error("Error parsing SSE data:", e);
            }
        };

        eventSource.onerror = function (event) {
            console.error("SSE error:", event);
            if (sseStatusDiv) {
                sseStatusDiv.classList.remove('alert-info');
                sseStatusDiv.classList.add('alert-danger');
                sseStatusDiv.textContent = 'Live stream disconnected. Attempting to reconnect...';
            }
            setApiStatus('danger', 'Stream Error');
            // EventSource automatically attempts reconnection on error
            // Close manually if needed: eventSource.close();
        };
    }

    function disconnectSSE() {
        if (eventSource) {
            console.log("Closing SSE connection.");
            eventSource.close();
            eventSource = null;
            if (sseStatusDiv) sseStatusDiv.classList.add('d-none');
        }
    }
    // --- End NEW ---


    // Refresh function for this page
    function refreshPageData() {
        console.log("Refreshing events page data...");
        fetchEvents(); // Fetch historical data
    }

    // Event Listeners
    unlabeledOnlySwitch?.addEventListener('change', fetchEvents);
    limitSelect?.addEventListener('change', fetchEvents);
    labelForm?.addEventListener('submit', handleLabelSubmit);
    // Global refresh button listener is in base.html

    // Initial Load
    document.addEventListener('DOMContentLoaded', () => {
        if (!eventDetailsModal) console.error("Bootstrap modal instance could not be created.");
        refreshPageData(); // Fetch initial historical data
        connectSSE(); // Connect to the SSE stream
    });

    // Clean up SSE connection when page is unloaded (optional but good practice)
    window.addEventListener('beforeunload', disconnectSSE);

</script>
{% endblock %}